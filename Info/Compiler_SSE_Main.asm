; Listing generated by Microsoft (R) Optimizing Compiler Version 19.21.27702.2 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@OOMENCHE@SSE?5test?5failed?4?6@	; `string'
PUBLIC	??_C@_03GCDGINBO@ref@				; `string'
PUBLIC	??_C@_03OEPHKLAG@SSE@				; `string'
PUBLIC	??_C@_0DA@KNEDKHD@?$CF12s?3?5?$CF?42f?5average?5cycles?5?$HM?5?$CF?42@ ; `string'
PUBLIC	??_C@_0BE@DLMGCPEG@All?5tests?5correct?4?6@	; `string'
PUBLIC	?gAntiOptimizationMask@@3HA			; gAntiOptimizationMask
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	rand:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	srand:PROC
EXTRN	__security_check_cookie:PROC
?gAntiOptimizationMask@@3HA DD 01H DUP (?)		; gAntiOptimizationMask
_BSS	ENDS
;	COMDAT ?perfVariants@?1??RunPerformanceTest@@YAXXZ@4QBU<unnamed-type-perfVariants>@?1??1@YAXXZ@B
CONST	SEGMENT
?perfVariants@?1??RunPerformanceTest@@YAXXZ@4QBU<unnamed-type-perfVariants>@?1??1@YAXXZ@B DQ FLAT:??_C@_03GCDGINBO@ref@ ; `RunPerformanceTest'::`2'::perfVariants
	DQ	FLAT:?RunRef@@YAXPEATVec4f@@PEBT1@1H@Z
	DQ	FLAT:??_C@_03OEPHKLAG@SSE@
	DQ	FLAT:?RunSSE@@YAXPEATVec4f@@PEBT1@1H@Z
CONST	ENDS
;	COMDAT ??_C@_0BE@DLMGCPEG@All?5tests?5correct?4?6@
CONST	SEGMENT
??_C@_0BE@DLMGCPEG@All?5tests?5correct?4?6@ DB 'All tests correct.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KNEDKHD@?$CF12s?3?5?$CF?42f?5average?5cycles?5?$HM?5?$CF?42@
CONST	SEGMENT
??_C@_0DA@KNEDKHD@?$CF12s?3?5?$CF?42f?5average?5cycles?5?$HM?5?$CF?42@ DB '%'
	DB	'12s: %.2f average cycles | %.2f lowest cycles', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEPHKLAG@SSE@
CONST	SEGMENT
??_C@_03OEPHKLAG@SSE@ DB 'SSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDGINBO@ref@
CONST	SEGMENT
??_C@_03GCDGINBO@ref@ DB 'ref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OOMENCHE@SSE?5test?5failed?4?6@
CONST	SEGMENT
??_C@_0BC@OOMENCHE@SSE?5test?5failed?4?6@ DB 'SSE test failed.', 0aH, 00H ; `string'
CONST	ENDS
PUBLIC	main
PUBLIC	?VecAddSSE@@YAXAEATVec4f@@AEBT1@1@Z		; VecAddSSE
PUBLIC	?VecAddRef@@YAXAEATVec4f@@AEBT1@1@Z		; VecAddRef
PUBLIC	printf
PUBLIC	fprintf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@3a800000
PUBLIC	__real@3e70000000000000
PUBLIC	__real@3f30000000000000
PUBLIC	__real@46800000
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RunTests@@YAHXZ DD imagerel ?RunTests@@YAHXZ
	DD	imagerel ?RunTests@@YAHXZ+224
	DD	imagerel $unwind$?RunTests@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RunTests@@YAHXZ DD imagerel ?RunTests@@YAHXZ+224
	DD	imagerel ?RunTests@@YAHXZ+619
	DD	imagerel $chain$3$?RunTests@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?RunTests@@YAHXZ DD imagerel ?RunTests@@YAHXZ+619
	DD	imagerel ?RunTests@@YAHXZ+685
	DD	imagerel $chain$4$?RunTests@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RunPerformanceTest@@YAXXZ DD imagerel ?RunPerformanceTest@@YAXXZ
	DD	imagerel ?RunPerformanceTest@@YAXXZ+443
	DD	imagerel $unwind$?RunPerformanceTest@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RunCorrectnessTest@@YAHXZ DD imagerel ?RunCorrectnessTest@@YAHXZ
	DD	imagerel ?RunCorrectnessTest@@YAHXZ+293
	DD	imagerel $unwind$?RunCorrectnessTest@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RandVec@@YAXAEATVec4f@@@Z DD imagerel ?RandVec@@YAXAEATVec4f@@@Z
	DD	imagerel ?RandVec@@YAXAEATVec4f@@@Z+103
	DD	imagerel $unwind$?RandVec@@YAXAEATVec4f@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Randf@@YAMXZ DD imagerel ?Randf@@YAMXZ
	DD	imagerel ?Randf@@YAMXZ+37
	DD	imagerel $unwind$?Randf@@YAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN6
	DD	imagerel $LN6+68
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT __real@46800000
CONST	SEGMENT
__real@46800000 DD 046800000r			; 16384
CONST	ENDS
;	COMDAT __real@3f30000000000000
CONST	SEGMENT
__real@3f30000000000000 DQ 03f30000000000000r	; 0.000244141
CONST	ENDS
;	COMDAT __real@3e70000000000000
CONST	SEGMENT
__real@3e70000000000000 DQ 03e70000000000000r	; 5.96046e-08
CONST	ENDS
;	COMDAT __real@3a800000
CONST	SEGMENT
__real@3a800000 DD 03a800000r			; 0.000976563
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Randf@@YAMXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RandVec@@YAXAEATVec4f@@@Z DD 082101H
	DD	027821H
	DD	03680fH
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RunCorrectnessTest@@YAHXZ DD 092919H
	DD	07781aH
	DD	086815H
	DD	014340dH
	DD	012010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RunPerformanceTest@@YAXXZ DD 0e3419H
	DD	067825H
	DD	076820H
	DD	016641bH
	DD	015541bH
	DD	014341bH
	DD	0f014f21bH
	DD	07010e012H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?RunTests@@YAHXZ DD 021H
	DD	imagerel ?RunTests@@YAHXZ
	DD	imagerel ?RunTests@@YAHXZ+224
	DD	imagerel $unwind$?RunTests@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RunTests@@YAHXZ DD 082721H
	DD	012f427H
	DD	018e41fH
	DD	0176417H
	DD	0165408H
	DD	imagerel ?RunTests@@YAHXZ
	DD	imagerel ?RunTests@@YAHXZ+224
	DD	imagerel $unwind$?RunTests@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RunTests@@YAHXZ DD 082619H
	DD	077817H
	DD	086812H
	DD	013010aH
	DD	030027003H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 644  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Stream$ = 80
_Format$ = 88
fprintf	PROC						; COMDAT

; 835  :     {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rbx, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?VecAddRef@@YAXAEATVec4f@@AEBT1@1@Z
_TEXT	SEGMENT
out$ = 8
A$ = 16
B$ = 24
?VecAddRef@@YAXAEATVec4f@@AEBT1@1@Z PROC		; VecAddRef, COMDAT

; 15   : 	for (int i = 0; i < 4; i++)
; 16   : 		out.m[i] = A.m[i] + B.m[i];

	movss	xmm0, DWORD PTR [rdx]
	addss	xmm0, DWORD PTR [r8]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm1, DWORD PTR [r8+4]
	movss	DWORD PTR [rcx+4], xmm1
	movss	xmm0, DWORD PTR [rdx+8]
	addss	xmm0, DWORD PTR [r8+8]
	movss	DWORD PTR [rcx+8], xmm0
	movss	xmm1, DWORD PTR [rdx+12]
	addss	xmm1, DWORD PTR [r8+12]
	movss	DWORD PTR [rcx+12], xmm1

; 17   : }

	ret	0
?VecAddRef@@YAXAEATVec4f@@AEBT1@1@Z ENDP		; VecAddRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?VecAddSSE@@YAXAEATVec4f@@AEBT1@1@Z
_TEXT	SEGMENT
out$ = 8
A$ = 16
B$ = 24
?VecAddSSE@@YAXAEATVec4f@@AEBT1@1@Z PROC		; VecAddSSE, COMDAT

; 21   : 	out.row = _mm_add_ps(A.row, B.row);

	movups	xmm0, XMMWORD PTR [rdx]
	addps	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rcx], xmm0

; 22   : }

	ret	0
?VecAddSSE@@YAXAEATVec4f@@AEBT1@1@Z ENDP		; VecAddSSE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?Randf@@YAMXZ
_TEXT	SEGMENT
?Randf@@YAMXZ PROC					; Randf, COMDAT

; 30   : {

	sub	rsp, 40					; 00000028H

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, DWORD PTR __real@46800000
	mulss	xmm0, DWORD PTR __real@3a800000

; 32   : }

	add	rsp, 40					; 00000028H
	ret	0
?Randf@@YAMXZ ENDP					; Randf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?RandVec@@YAXAEATVec4f@@@Z
_TEXT	SEGMENT
M$ = 80
?RandVec@@YAXAEATVec4f@@@Z PROC				; RandVec, COMDAT

; 35   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rdi, rcx
	movss	xmm6, DWORD PTR __real@46800000
	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+32], xmm7
	movss	xmm7, DWORD PTR __real@3a800000
	npad	7
$LL4@RandVec:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 36   : 	for (int i = 0; i < 4; i++)
; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR [rdi+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL4@RandVec

; 38   : }

	mov	rbx, QWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?RandVec@@YAXAEATVec4f@@@Z ENDP				; RandVec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?RunRef@@YAXPEATVec4f@@PEBT1@1H@Z
_TEXT	SEGMENT
out$ = 8
A$ = 16
B$ = 24
count$ = 32
?RunRef@@YAXPEATVec4f@@PEBT1@1H@Z PROC			; RunRef, COMDAT

; 48   : 	for (int i = 0; i < count; i++)

	test	r9d, r9d
	jle	SHORT $LN3@RunRef
	movsxd	r11, DWORD PTR ?gAntiOptimizationMask@@3HA ; gAntiOptimizationMask
	xor	r10d, r10d
	mov	r9d, r9d
$LL4@RunRef:

; 49   : 	{
; 50   : 		int j = i & gAntiOptimizationMask; // Only take first element

	mov	rax, r10
	inc	r10
	and	rax, r11
	lea	rax, QWORD PTR [rax*4]

; 16   : 		out.m[i] = A.m[i] + B.m[i];

	movss	xmm0, DWORD PTR [r8+rax*4]
	addss	xmm0, DWORD PTR [rdx+rax*4]
	movss	DWORD PTR [rcx+rax*4], xmm0
	movss	xmm1, DWORD PTR [r8+rax*4+4]
	addss	xmm1, DWORD PTR [rdx+rax*4+4]
	movss	DWORD PTR [rcx+rax*4+4], xmm1
	movss	xmm0, DWORD PTR [rdx+rax*4+8]
	addss	xmm0, DWORD PTR [r8+rax*4+8]
	movss	DWORD PTR [rcx+rax*4+8], xmm0
	movss	xmm1, DWORD PTR [rdx+rax*4+12]
	addss	xmm1, DWORD PTR [r8+rax*4+12]
	movss	DWORD PTR [rcx+rax*4+12], xmm1

; 48   : 	for (int i = 0; i < count; i++)

	sub	r9, 1
	jne	SHORT $LL4@RunRef
$LN3@RunRef:

; 51   : 		VecAddRef(out[j], A[j], B[j]);
; 52   : 	}
; 53   : }

	ret	0
?RunRef@@YAXPEATVec4f@@PEBT1@1H@Z ENDP			; RunRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?RunSSE@@YAXPEATVec4f@@PEBT1@1H@Z
_TEXT	SEGMENT
out$ = 8
A$ = 16
B$ = 24
count$ = 32
?RunSSE@@YAXPEATVec4f@@PEBT1@1H@Z PROC			; RunSSE, COMDAT

; 57   : 	for (int i = 0; i < count; i++)

	test	r9d, r9d
	jle	SHORT $LN3@RunSSE
	movsxd	r11, DWORD PTR ?gAntiOptimizationMask@@3HA ; gAntiOptimizationMask
	xor	r10d, r10d
	mov	r9d, r9d
	npad	14
$LL4@RunSSE:

; 58   : 	{
; 59   : 		int j = i & gAntiOptimizationMask; // Only take first element

	mov	rax, r10
	inc	r10
	and	rax, r11

; 60   : 		VecAddSSE(out[j], A[j], B[j]);

	add	rax, rax

; 21   : 	out.row = _mm_add_ps(A.row, B.row);

	movups	xmm0, XMMWORD PTR [rdx+rax*8]
	addps	xmm0, XMMWORD PTR [r8+rax*8]
	movups	XMMWORD PTR [rcx+rax*8], xmm0

; 57   : 	for (int i = 0; i < count; i++)

	sub	r9, 1
	jne	SHORT $LL4@RunSSE
$LN3@RunSSE:

; 61   : 	}
; 62   : }

	ret	0
?RunSSE@@YAXPEATVec4f@@PEBT1@1H@Z ENDP			; RunSSE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?RunCorrectnessTest@@YAHXZ
_TEXT	SEGMENT
A$2 = 32
B$3 = 48
out$4 = 64
ref_out$5 = 80
__$ArrayPad$ = 96
?RunCorrectnessTest@@YAHXZ PROC				; RunCorrectnessTest, COMDAT

; 67   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 144				; 00000090H
	movaps	XMMWORD PTR [rsp+128], xmm6
	movaps	XMMWORD PTR [rsp+112], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 68   : 	srand(1234); // Fixed seed

	mov	ecx, 1234				; 000004d2H
	call	srand

; 69   : 
; 70   : 	for (int i = 0; i < 1000000; i++)

	movss	xmm6, DWORD PTR __real@46800000
	xor	edi, edi
	movss	xmm7, DWORD PTR __real@3a800000
$LL4@RunCorrect:

; 36   : 	for (int i = 0; i < 4; i++)

	xor	ebx, ebx
$LL10@RunCorrect:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR A$2[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL10@RunCorrect

; 36   : 	for (int i = 0; i < 4; i++)

	xor	ebx, ebx
	npad	4
$LL17@RunCorrect:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR B$3[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL17@RunCorrect

; 16   : 		out.m[i] = A.m[i] + B.m[i];

	movaps	xmm1, XMMWORD PTR A$2[rsp]
	movaps	xmm2, xmm1
	addps	xmm2, XMMWORD PTR B$3[rsp]

; 21   : 	out.row = _mm_add_ps(A.row, B.row);

	addps	xmm1, XMMWORD PTR B$3[rsp]

; 71   : 	{
; 72   : 		Vec4f A, B, out, ref_out;
; 73   : 		RandVec(A);
; 74   : 		RandVec(B);
; 75   : 
; 76   : 		VecAddRef(ref_out, A, B);
; 77   : 		VecAddSSE(out, A, B);
; 78   : 
; 79   : 		if (memcmp(&out, &ref_out, sizeof(out)) != 0)

	movq	rax, xmm2

; 16   : 		out.m[i] = A.m[i] + B.m[i];

	movaps	XMMWORD PTR ref_out$5[rsp], xmm2

; 71   : 	{
; 72   : 		Vec4f A, B, out, ref_out;
; 73   : 		RandVec(A);
; 74   : 		RandVec(B);
; 75   : 
; 76   : 		VecAddRef(ref_out, A, B);
; 77   : 		VecAddSSE(out, A, B);
; 78   : 
; 79   : 		if (memcmp(&out, &ref_out, sizeof(out)) != 0)

	movq	rcx, xmm1

; 21   : 	out.row = _mm_add_ps(A.row, B.row);

	movaps	XMMWORD PTR out$4[rsp], xmm1

; 71   : 	{
; 72   : 		Vec4f A, B, out, ref_out;
; 73   : 		RandVec(A);
; 74   : 		RandVec(B);
; 75   : 
; 76   : 		VecAddRef(ref_out, A, B);
; 77   : 		VecAddSSE(out, A, B);
; 78   : 
; 79   : 		if (memcmp(&out, &ref_out, sizeof(out)) != 0)

	cmp	rcx, rax
	jne	SHORT $LN32@RunCorrect
	mov	rax, QWORD PTR out$4[rsp+8]
	cmp	rax, QWORD PTR ref_out$5[rsp+8]
	jne	SHORT $LN32@RunCorrect

; 69   : 
; 70   : 	for (int i = 0; i < 1000000; i++)

	inc	edi
	cmp	edi, 1000000				; 000f4240H
	jl	$LL4@RunCorrect

; 83   : 		}
; 84   : 	}
; 85   : 
; 86   : 	return EXIT_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN1@RunCorrect
$LN32@RunCorrect:

; 80   : 		{
; 81   : 			fprintf(stderr, "SSE test failed.\n");

	mov	ecx, 2
	call	__acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0BC@OOMENCHE@SSE?5test?5failed?4?6@
	call	fprintf

; 82   : 			return EXIT_FAILURE;

	mov	eax, 1
$LN1@RunCorrect:

; 87   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
?RunCorrectnessTest@@YAHXZ ENDP				; RunCorrectnessTest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?RunPerformanceTest@@YAXXZ
_TEXT	SEGMENT
Bperf$ = 32
Aperf$ = 48
out$ = 64
__$ArrayPad$ = 80
?RunPerformanceTest@@YAXXZ PROC				; RunPerformanceTest, COMDAT

; 90   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	movaps	XMMWORD PTR [rsp+112], xmm6
	movaps	XMMWORD PTR [rsp+96], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movss	xmm6, DWORD PTR __real@46800000
	xor	ebx, ebx
	movss	xmm7, DWORD PTR __real@3a800000
$LL13@RunPerform:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR Aperf$[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL13@RunPerform
	xor	ebx, ebx
	npad	5
$LL20@RunPerform:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR Bperf$[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL20@RunPerform
	movsd	xmm6, QWORD PTR __real@3f30000000000000
	lea	r14, OFFSET FLAT:?perfVariants@?1??RunPerformanceTest@@YAXXZ@4QBU<unnamed-type-perfVariants>@?1??1@YAXXZ@B
	movsd	xmm7, QWORD PTR __real@3e70000000000000
	lea	r15, OFFSET FLAT:?perfVariants@?1??RunPerformanceTest@@YAXXZ@4QBU<unnamed-type-perfVariants>@?1??1@YAXXZ@B+32
	npad	15
$LL4@RunPerform:

; 91   : 	static constexpr struct {
; 92   : 		const char* name;
; 93   : 		void (*Run)(Vec4f* out, const Vec4f* A, const Vec4f* B, int count);
; 94   : 	} perfVariants[] = {
; 95   : 		{ "ref",  RunRef },
; 96   : 		{ "SSE",  RunSSE },
; 97   : 	};
; 98   : 	static constexpr int nPerfVars = (int)(sizeof(perfVariants) / sizeof(*perfVariants));
; 99   : 
; 100  : 	Vec4f Aperf, Bperf, out;
; 101  : 	RandVec(Aperf);
; 102  : 	RandVec(Bperf);
; 103  : 
; 104  : 	for (int i = 0; i < nPerfVars; i++)
; 105  : 	{
; 106  : 		static constexpr int nRuns = 4096;
; 107  : 		static constexpr int addsPerRun = 4096;
; 108  : 
; 109  : 		unsigned long long bestTime = ~0ull;

	mov	rdi, -1

; 110  : 		unsigned long long sumTime = 0ull;

	xor	esi, esi
	mov	ebp, 4096				; 00001000H
	npad	2
$LL7@RunPerform:

; 111  : 
; 112  : 		for (int run = 0; run < nRuns; run++)
; 113  : 		{
; 114  : 			unsigned long long time = __rdtsc(); // The processor time stamp records the number of clock cycles since the last reset

	rdtsc
	shl	rdx, 32					; 00000020H

; 115  : 			perfVariants[i].Run(&out, &Aperf, &Bperf, addsPerRun);

	lea	r8, QWORD PTR Bperf$[rsp]
	or	rax, rdx
	lea	rcx, QWORD PTR out$[rsp]
	lea	rdx, QWORD PTR Aperf$[rsp]
	mov	r9d, 4096				; 00001000H
	mov	rbx, rax
	call	QWORD PTR [r14+8]

; 116  : 			time = __rdtsc() - time;

	rdtsc
	shl	rdx, 32					; 00000020H
	or	rax, rdx
	sub	rax, rbx

; 117  : 
; 118  : 			sumTime += time;

	add	rsi, rax
	cmp	rax, rdi
	cmovae	rax, rdi
	mov	rdi, rax
	sub	rbp, 1
	jne	SHORT $LL7@RunPerform

; 125  : 		double cyclesPerRun = (double)bestTime / (double)addsPerRun;

	xorps	xmm3, xmm3
	test	rax, rax
	js	SHORT $LN42@RunPerform
	cvtsi2sd xmm3, rax
	jmp	SHORT $LN43@RunPerform
$LN42@RunPerform:
	shr	rax, 1
	and	edi, 1
	or	rax, rdi
	cvtsi2sd xmm3, rax
	addsd	xmm3, xmm3
$LN43@RunPerform:
	mulsd	xmm3, xmm6
	xorps	xmm2, xmm2
	test	rsi, rsi
	js	SHORT $LN40@RunPerform

; 119  : 
; 120  : 			if (time < bestTime)
; 121  : 				bestTime = time;
; 122  : 		}
; 123  : 
; 124  : 		double avgTime = (double)sumTime / (double)(addsPerRun * nRuns);

	cvtsi2sd xmm2, rsi
	jmp	SHORT $LN41@RunPerform
$LN40@RunPerform:
	mov	rax, rsi
	and	esi, 1
	shr	rax, 1
	or	rax, rsi
	cvtsi2sd xmm2, rax
	addsd	xmm2, xmm2
$LN41@RunPerform:

; 126  : 		printf("%12s: %.2f average cycles | %.2f lowest cycles\n", perfVariants[i].name, avgTime, cyclesPerRun);

	mov	rdx, QWORD PTR [r14]
	lea	rcx, OFFSET FLAT:??_C@_0DA@KNEDKHD@?$CF12s?3?5?$CF?42f?5average?5cycles?5?$HM?5?$CF?42@
	mulsd	xmm2, xmm7
	movq	r9, xmm3
	movq	r8, xmm2
	call	printf
	add	r14, 16
	cmp	r14, r15
	jl	$LL4@RunPerform

; 127  : 	}
; 128  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?RunPerformanceTest@@YAXXZ ENDP				; RunPerformanceTest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\InstructionSetLevel.h
;	COMDAT ?RunTests@@YAHXZ
_TEXT	SEGMENT
Aperf$3 = 32
out$4 = 32
Bperf$5 = 48
ref_out$6 = 48
out$7 = 64
B$8 = 64
A$9 = 80
__$ArrayPad$ = 96
?RunTests@@YAHXZ PROC					; RunTests, COMDAT

; 131  : {

	push	rbx
	push	rdi
	sub	rsp, 152				; 00000098H
	movaps	XMMWORD PTR [rsp+128], xmm6
	movaps	XMMWORD PTR [rsp+112], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 68   : 	srand(1234); // Fixed seed

	mov	ecx, 1234				; 000004d2H
	call	srand

; 69   : 
; 70   : 	for (int i = 0; i < 1000000; i++)

	movss	xmm6, DWORD PTR __real@46800000
	xor	edi, edi
	movss	xmm7, DWORD PTR __real@3a800000
$LL7@RunTests:

; 36   : 	for (int i = 0; i < 4; i++)

	xor	ebx, ebx
$LL13@RunTests:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR A$9[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL13@RunTests

; 36   : 	for (int i = 0; i < 4; i++)

	xor	ebx, ebx
	npad	7
$LL20@RunTests:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR B$8[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL20@RunTests

; 16   : 		out.m[i] = A.m[i] + B.m[i];

	movaps	xmm1, XMMWORD PTR A$9[rsp]
	movaps	xmm2, xmm1
	addps	xmm2, XMMWORD PTR B$8[rsp]

; 21   : 	out.row = _mm_add_ps(A.row, B.row);

	addps	xmm1, XMMWORD PTR B$8[rsp]

; 79   : 		if (memcmp(&out, &ref_out, sizeof(out)) != 0)

	movq	rax, xmm2

; 16   : 		out.m[i] = A.m[i] + B.m[i];

	movaps	XMMWORD PTR ref_out$6[rsp], xmm2

; 79   : 		if (memcmp(&out, &ref_out, sizeof(out)) != 0)

	movq	rcx, xmm1

; 21   : 	out.row = _mm_add_ps(A.row, B.row);

	movaps	XMMWORD PTR out$4[rsp], xmm1

; 79   : 		if (memcmp(&out, &ref_out, sizeof(out)) != 0)

	cmp	rcx, rax
	jne	$LN62@RunTests
	mov	rax, QWORD PTR out$4[rsp+8]
	cmp	rax, QWORD PTR ref_out$6[rsp+8]
	jne	$LN62@RunTests

; 69   : 
; 70   : 	for (int i = 0; i < 1000000; i++)

	inc	edi
	cmp	edi, 1000000				; 000f4240H
	jl	$LL7@RunTests

; 134  : 	
; 135  : 	printf("All tests correct.\n");

	mov	QWORD PTR [rsp+176], rbp
	lea	rcx, OFFSET FLAT:??_C@_0BE@DLMGCPEG@All?5tests?5correct?4?6@
	mov	QWORD PTR [rsp+184], rsi
	mov	QWORD PTR [rsp+192], r14
	mov	QWORD PTR [rsp+144], r15
	call	printf
	xor	ebx, ebx
	npad	2
$LL43@RunTests:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR Aperf$3[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL43@RunTests
	xor	ebx, ebx
$LL50@RunTests:

; 31   : 	return (rand() - 16384.0f) / 1024.0f;

	call	rand
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm6
	mulss	xmm0, xmm7

; 37   : 		M.m[i] = Randf();

	movss	DWORD PTR Bperf$5[rsp+rbx*4], xmm0
	inc	rbx
	cmp	rbx, 4
	jl	SHORT $LL50@RunTests
	movsd	xmm6, QWORD PTR __real@3f30000000000000
	lea	r14, OFFSET FLAT:?perfVariants@?1??RunPerformanceTest@@YAXXZ@4QBU<unnamed-type-perfVariants>@?1??1@YAXXZ@B
	movsd	xmm7, QWORD PTR __real@3e70000000000000
	lea	r15, OFFSET FLAT:?perfVariants@?1??RunPerformanceTest@@YAXXZ@4QBU<unnamed-type-perfVariants>@?1??1@YAXXZ@B+32
	npad	10
$LL34@RunTests:

; 109  : 		unsigned long long bestTime = ~0ull;

	mov	rdi, -1

; 110  : 		unsigned long long sumTime = 0ull;

	xor	esi, esi
	mov	ebp, 4096				; 00001000H
	npad	2
$LL37@RunTests:

; 111  : 
; 112  : 		for (int run = 0; run < nRuns; run++)
; 113  : 		{
; 114  : 			unsigned long long time = __rdtsc(); // The processor time stamp records the number of clock cycles since the last reset

	rdtsc
	shl	rdx, 32					; 00000020H

; 115  : 			perfVariants[i].Run(&out, &Aperf, &Bperf, addsPerRun);

	lea	r8, QWORD PTR Bperf$5[rsp]
	or	rax, rdx
	lea	rcx, QWORD PTR out$7[rsp]
	lea	rdx, QWORD PTR Aperf$3[rsp]
	mov	r9d, 4096				; 00001000H
	mov	rbx, rax
	call	QWORD PTR [r14+8]

; 116  : 			time = __rdtsc() - time;

	rdtsc
	shl	rdx, 32					; 00000020H
	or	rax, rdx
	sub	rax, rbx

; 117  : 
; 118  : 			sumTime += time;

	add	rsi, rax
	cmp	rax, rdi
	cmovae	rax, rdi
	mov	rdi, rax
	sub	rbp, 1
	jne	SHORT $LL37@RunTests

; 125  : 		double cyclesPerRun = (double)bestTime / (double)addsPerRun;

	xorps	xmm3, xmm3
	test	rax, rax
	js	SHORT $LN98@RunTests
	cvtsi2sd xmm3, rax
	jmp	SHORT $LN99@RunTests
$LN98@RunTests:
	shr	rax, 1
	and	edi, 1
	or	rax, rdi
	cvtsi2sd xmm3, rax
	addsd	xmm3, xmm3
$LN99@RunTests:
	mulsd	xmm3, xmm6
	xorps	xmm2, xmm2
	test	rsi, rsi
	js	SHORT $LN96@RunTests

; 119  : 
; 120  : 			if (time < bestTime)
; 121  : 				bestTime = time;
; 122  : 		}
; 123  : 
; 124  : 		double avgTime = (double)sumTime / (double)(addsPerRun * nRuns);

	cvtsi2sd xmm2, rsi
	jmp	SHORT $LN97@RunTests
$LN96@RunTests:
	mov	rax, rsi
	and	esi, 1
	shr	rax, 1
	or	rax, rsi
	cvtsi2sd xmm2, rax
	addsd	xmm2, xmm2
$LN97@RunTests:

; 126  : 		printf("%12s: %.2f average cycles | %.2f lowest cycles\n", perfVariants[i].name, avgTime, cyclesPerRun);

	mov	rdx, QWORD PTR [r14]
	lea	rcx, OFFSET FLAT:??_C@_0DA@KNEDKHD@?$CF12s?3?5?$CF?42f?5average?5cycles?5?$HM?5?$CF?42@
	mulsd	xmm2, xmm7
	movq	r9, xmm3
	movq	r8, xmm2
	call	printf
	add	r14, 16
	cmp	r14, r15
	jl	$LL34@RunTests

; 136  : 
; 137  : 	RunPerformanceTest();
; 138  : 
; 139  : 	return EXIT_SUCCESS;

	mov	r15, QWORD PTR [rsp+144]
	xor	eax, eax
	mov	r14, QWORD PTR [rsp+192]
	mov	rsi, QWORD PTR [rsp+184]
	mov	rbp, QWORD PTR [rsp+176]
	jmp	SHORT $LN1@RunTests
$LN62@RunTests:

; 81   : 			fprintf(stderr, "SSE test failed.\n");

	mov	ecx, 2
	call	__acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0BC@OOMENCHE@SSE?5test?5failed?4?6@
	call	fprintf

; 132  : 	if (RunCorrectnessTest())
; 133  : 		return EXIT_FAILURE;

	mov	eax, 1
$LN1@RunTests:

; 140  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+128]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rbx
	ret	0
?RunTests@@YAHXZ ENDP					; RunTests
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\#Programming\Parallelism\Main.cpp
;	COMDAT main
_TEXT	SEGMENT
argc$ = 8
argv$ = 16
main	PROC						; COMDAT

; 11   : 	return RunTests();

	jmp	?RunTests@@YAHXZ			; RunTests
main	ENDP
_TEXT	ENDS
END
